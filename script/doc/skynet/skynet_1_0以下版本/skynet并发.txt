##并发##
	skynet的并发是基于单进程多线程并发，协程只是异步回调代码同步化写法，和并发没有一点关系。
	skynet的一个服务对应一个Lua_State,一个服务同时可以被多个worker线程执行，因此多次会话可以
	并行执行，lua层fork_queue在每次会话完后都会全部执行，因此用skynet.fork包装的函数可以和
	调用者代码并行执行，同样，skynet.wakeup原理也差不多，当条件足够时对唤醒协程做标记(置入待
	唤醒表wakeup_session),每次会话都会调度wakeup_session，这样就可以及时唤醒等待的协程。skynet
	基于消息驱动，消息队列是多线程共享的，引擎已经对消息队列的入队、出队做了加锁处理，因此
	业务层无需考虑并发逻辑，当然业务层如果用阻塞api（业务层的阻塞api都是指只阻塞本次会话/当前
	运行协程），仍然要考虑代码重入问题，如载入数据，为了避免对同一份数据多次载入，我们可以对
	载入数据做状态标记来阻止多次载入。

##减少IO阻塞##
	IO按来源一般可以分成网络IO和本地IO，如果db/日志放到本服，那db/日志的IO我们可以称为本地
	IO，对于网络IO阻塞，开单独线程利用epoll可以完满解决，对于读取本地文件的IO，也可以通过开
	其他线程来专门处理IO密集型计算，这样可以减少CPU密集型线程的IO阻塞。在skynet中网络IO引擎
	以为我们处理好，而本地IO我们可以通过开单独的服务让IO阻塞只限定在特定服，通常我们可以专门
	开logger服务和db服务
